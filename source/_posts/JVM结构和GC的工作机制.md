---
title: JVM结构和GC的工作机制
date: 2017-03-25 19:18:46
categories: Java后台
tags:
- Java
---

> 参考：[http://blog.csdn.net/moneyshi/article/details/53033577](http://blog.csdn.net/moneyshi/article/details/53033577)

## JVM结构
![jvm](/uploads/20170309052107625.jpeg)

<!-- more -->

![jvm2](/uploads/20170309052117048.jpeg)

从图一可知，jvm主要包括四个部分：

1. `类加载器`（ClassLoader）
	- 在jvm启动时或类运行时将需要的class加载到jvm中。
2. `执行引擎`
	- 负责执行class文件中的字节码指令。
3. `本地方法接口`
	- 主要是调用C或者C++实现的本地方法及返回结果。
4. `内存区`
	- jvm在运行时操作系统所分配的内存区，主要分为5个区。
	- ![mem](/uploads/20170309052142757.jpeg)
	- `方法区`（Methor Area）
		- 用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。被所有java线程共享。
	- `java堆`（Heap）
		- 存储java对象或实例的地方。这块是GC的主要区域， 被所有java线程共享。
	- `java栈`（Stack）
		- java栈总是和线程关联在一起，每当创建一个线程时，jvm就会为这个线程创建一个栈。栈中会包含很多栈帧，没运行一个方法就会创建一个栈帧，用于存储局部变量返回值等。每一个方法从调用到结束，就是一个栈帧从入栈到出栈的过程。java栈是线程私有的。
	- `程序计数器`（PC Register）
		- 用于保存当前线程的内存地址。由于jvm是多线程的，线程轮流切换，为了保证线程切换回来后还能恢复原先状态，就需要一个独立的计数器，记录之前中断的地方。程序计数器也是线程私有的。
	- `本地方法栈`（Native Method Stack）
		- 和java栈作用差不多，只不过是为native方法服务的。java线程私有的。	 

## 内存分配
在了解GC之前，需要先了解一下jvm是怎么分配内存的，然后识别哪些垃圾需要回收，以及用什么方式去回收。

java内存分配和C/C++不同，C每次申请内存都是手动的进行系统调用，这需要一定的开销，而jvm是一次性分配一大块内存，然后每次new的时候都在这块空间上分配和释放。减少系统调用次数，节省了一定的开销，有点类似于线程池的概念。

有了这块空间之后，如何进行分配和回收就和GC有关了。

java的内存申请一般有两种：`静态内存和动态内存`。编译时就能确定大小的就是静态内容，比如int类型变量。动态内存是指在运行期间才能知道大小的，比如java对象。

由于java栈、程序计数器、本地方法栈都是线程私有的，线程生则生，线程灭则灭，这几个区域的内存回收是确定的。但是java堆和方法区则不一样，只有在运行期间才知道创建哪些对象，这部分的内存回收是动态的，一般GC主要是针对这一块。

总之，栈的内存管理是顺序的，而且定长，不存在内存回收问题，堆则是为java动态分配内存，不定长度，所以存在内存分配和回收的问题。

## 垃圾检测、回收算法
GC一般要做两件事，一是检测出垃圾，二是回收垃圾。

### 检测垃圾一般有下面这些方法：
#### 引用计数器
给对象添加一个计数器，每当有人引用他，计数器就加1，引用失效就减1，计数为0时被回收。

不足：当A和B互相引用时，可能会导致无法回收。

#### 可达性分析算法
以根集对象为起点进行搜索，如果对象不可达则回收，跟集一般包括java栈中的引用对象，还有方法区、常量池以及本地方法区中引用的对象。

总之，垃圾回收的时候，会检测所有堆中的对象，没用被引用的对象就会被回收。

### 一般回收算法有如下几种
#### 标记-清除（make-sweep）
算法如名，分为两个阶段：标记 清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的算法都是基于这个算法扩展的。

不足：效率低，标记清除之后会产生大量碎片，如下图：

![make_sweep](/uploads/20170309052126121.png)

#### 复制
此算法是把内存空间划分为两个相等的区域，每次只使用其中一个区域，当垃圾回收时，遍历当前使用的区域，把正在使用汇总的对象复制到另外一个区域，此算法每次只需要处理正在使用中的对象，
因此复制成本较小，同时，复制过去时还能进行内存整理，不会出现碎片，缺点也很明显，就是需要两倍空间。

![copy](/uploads/20170309052055174.png)

### 标记-整理（make-compact）
此算法结合了标记清除和复制算法的优点，也是分为两个阶段，第一阶段从跟节点开始标记所有被引用的对象，第二阶段遍历整个堆，清除未标记的对象，并且把存活的对象“压缩”到一块，按顺序排放，此算法避免了碎片问题，同时也避免了两倍空间问题。

![mark_compact](/uploads/20170309052134020.png)

### 分代收集算法
这是一个商用的垃圾收集算法，不同的对象有不同的生命周期，不同的生命周期采用不同的回收算法，分而治之，因地制宜。比较复杂，这里不多讨论。












